\section{性能测试与分析}

本章将对本课题目前的开发进度进行介绍，说明课题目前所取得的进展。同时，本章将介绍本课题目前所做的
一些实验性测试，对实验数据进行分析，并解读实验数据对于本课题的意义。

\subsection{测试环境}

本课题的所有开发与测试工作均在Linux操作系统下进行。本课题的开发与测试分别在本地与远程服务器上进行。
视开发测试环境不同，本课题所使用的Linux发行版亦有所不同。在本地环境下，所使用的Linux发行版为
Fedora 34 x86\_64版本，所使用的内核版本则为5.13.12-200.fc34.x86\_64。而在远程的服务器上，
使用的Linux发行版则为Ubuntu 18.04，内核版本为5.4.0-80-generic。

\subsection{带缓存的Picorv32处理器架构的仿真测试}

对于带缓存的Picorv32的仿真测试使用Verilator高性能仿真工具进行仿真测试。Verilator作为仿真工具，
将Verilog硬件描述语言转换为对应的C++语言代码，通过GCC进行编译得到用于仿真的可执行程序。同时，
Verilator高性能仿真工具还能通过函数调用生成波形图，便于开发过程中的调试与仿真。

\subsubsection{测试框架的编写}

对于带缓存的Picorv32处理器框架的仿真测试与验证是在被称为Testbench的测试框架中进行的。Testbench
是一种不可综合的仿真测试框架，通常会使用一些不可综合的仿真语法，以便与实现一些便于调试但在实际的
开发板上难以实现的功能，如延时、打印或读取文件等。

对于带缓存的Picorv32处理器架构而言，测试框架主要为其提供了一片可通过AXI Lite总线进行访存的仿真
内存模型。该模型能够提供一定大小的内存区用于测试程序的存储与运行。同时，该模型还提供了便于调试的
串口输出功能，以便于测试程序对运行情况进行输出，便于调试。处理器核可以通过访问特定的内存地址实现
来进行输出与调试。在设计上，指定0x1000\_0000为串口输出的地址，处理器核通过向该地址写入一个字节
的数据来实现单个字节的串口输出。当测试程序执行结束时，处理器核向0x2000\_0000处写入特定的验证
数据，以表示测试程序的正常结束。

除此之外，测试程序还提供了如下的仿真测试功能。

\begin{enumerate}
  \item 对带缓存的Picorv32处理器核架构进行配置与例化，并将其与测试框架相连接；
  \item 对仿真内存模型进行例化；
  \item 将用于测试的测试程序载入到仿真内存模型中；
  \item 为仿真测试系统提供时钟与复位信号；
  \item 监测处理器核对测试程序的执行情况，在测试程序正确执行完成后结束仿真测试；
  \item 根据配置，利用\$dumpfile系统函数对调试过程中的模块信号进行记录，生成并输出波形。
\end{enumerate}

\subsubsection{仿真测试结果}

在本课题的测试中，主要比较了带缓存的Picorv32处理器核架构与不带缓存的Picorv32处理器核架构在执行
特定测试程序时的性能差异，以衡量带缓存的Picorv32处理器核设计在性能上是否优于不带缓存的Picorv32
处理器核设计。同时，通过调节仿真测试框架中仿真内存模型的访存时延，本课题将能得到两种设计在不同的
外部访存速度下的性能差异。

\begin{generaltab}{不同访存延时下两种设计的性能差异}{tbl:verif_pico_delay}
  \begin{tabular}{c|cc}
    \toprule
    访存延时（周期） & CPI（带缓存） & CPI（不带缓存） \\
    \midrule
    5 & 6.82 & 13.87 \\
    10 & 7.46 & 21.49 \\
    15 & 8.20 & 29.84 \\
    20 & 9.04 & 38.93 \\
    25 & 9.94 & 48.92 \\
    \bottomrule
  \end{tabular}
\end{generaltab}

可以看到，随着访存延时的增加，带缓存的架构设计与不带缓存的架构设计在测试中所得到的性能表现均呈现出
了下降态势。这是符合实验预期的。但同时从数据上也可以看出，带缓存的架构设计的CPI随着访存延时的增加
而增加的增幅要远远小于不带缓存的架构设计。随着访存延时的增大，这两种架构设计之间的性能差异也就越来
越大。可以看到，当访存延时达到25个周期时，带缓存的设计与不带缓存的设计之间的性能差异可以达到4倍
以上。

因此，结合\autoref{tbl:verif_pico_delay}所给出的数据，为Picorv32增加缓存能够显著地提升其
在访存系统中的性能表现。因而也更适合被用于智能网卡上的网络数据包处理应用。

\subsection{基于Corundum的访存架构的测试与验证}

本课题完成了对于Corudum缓存队列的相关修改，并在此基础上进行了测试。出于测试的简单性考虑，同时也
受制于现有的项目进度，目前对于松散RISC-V多核架构的仿真测试主要是针对缓存队列的测试。本课题完成了
对于缓存队列的相关修改，并接入了单个的Picorv32处理器核作为网络处理器对数据包进行修改。在已完成
工作的基础上，本课题对所实现的基于Corundum缓存队列的访存架构进行了仿真测试与上板验证。

\subsubsection{使用Cocotb仿真测试框架进行仿真验证}

Corundum项目提供了基于Cocotb测试框架的仿真测试用例，用于对项目中各个模块单独进行仿真测试，验证
正确性。Cocotb是基于Python语言的快速仿真测试框架，可以用于快速地生成数字电路仿真测试用例\cite{cocotb_doc}。
结合已有的仿真测试框架，本课题对使用了支持内存访问的缓存队列的Corundum架构进行了仿真验证，并得到
了如\autoref{fig:verif_cocotb}所示的仿真结果。

\cpngfig{verif_cocotb}{使用Cocotb对基于Corundum的访存架构进行测试}{0.8}

对Corundum所进行的修改能够正确地通过Corundum项目所设立的仿真测试，因此可以认为本课题所作的修改
在实现上是正确且符合要求的。

\subsubsection{基于Xilinx Alveo U280的上板验证}

在完成了基于软件的仿真测试后，选择对架构进行FPGA上板验证。本课题上板验证的内容主要包括了基础功能
测试与性能测试。基础功能验证主要测试修改后的Corundum，作为集成了RISC-V处理器核的可编程智能网卡，
在部署上FPGA后，能够进行正常地网络通信；而性能测试则是对于这一过程的如带宽、延时等性能参数的测量。

为了将设计部署上FPGA，需要将Xilinx Alveo U280板卡插入到带有PCIe插槽的服务器主机上，并通过远程
访问服务器的方式进行部署与调试。同时，为了测试Xilinx Alveo U280的网络功能，使用100GbE的网络
线缆连接Xilinx Alveo U280板卡与部署在另一主机上的100GbE网卡，并配置好网络IP。完成硬件连接后，
使用Vivado开发工具组载入项目，生成比特流（Bitstream）并烧录到Xilinx Alveo U280上，即可完成
部署。

\subsubsubsection{基础功能测试}

对基础功能的测试将通过Linux系统自带的ping命令完成。在部署了U280板卡的主机上，使用ping命令进行
与另一主机的连通测试。

\cpngfig{verif_u280_connect}{基于U280板卡的基础功能测试}{0.8}

可以看到，使用ping命令能够正确地建立与物理上相连接的另一主机之间的网络连接，因此可以认为部署的
基础功能测试是成功的。

\subsubsubsection{性能测试与分析}

对于性能的测试则使用iperf工具完成。iperf工具是一种用于主动测量IP网络最大带宽的开源工具，支持多种
参数配置，并能够使用多种协议（如TCP、UDP等等）。在本测试中，对经过本课题修改后的实现进行了测试，
以分析本课题所设计访存架构对于Corundum网络接口控制器的性能影响。

\autoref{fig:verif_u280_iperf}展示了本课题的设计在性能测试中的输出。可以看到，经过本课题修改
后的带宽大概为2.8Gbps。而同样是在本课题的测试中，Corundum能够达到94Gbps的带宽。

\cpngfig{verif_u280_iperf}{基于U280板卡的性能测试}{0.9}

对比之下这样的结果显然并不算好。由此可见目前的实现仍然存在诸多可供完善的部分首先，目前的测试基于
单个Picorv32处理器核进行，侧重于验证基于Corundum的访存架构修改的可行性，而非最终的性能测试；
其次，在测试中Picorv32处理器核通过旁路访问缓存队列读取其上的网络数据包，这一过程通过多个总线
结构，因此访存开销较大，影响了处理器核的性能表现。

\subsection{本章小结}

在本章中，主要介绍了本课题目前所完成工作内容，并对目前所做的各种测试工作进行了描述。本章首先介绍了
本课题关于缓存架构对性能影响的测试。在这个测试中，通过比较带缓存的Picorv32架构与不带缓存的Picorv32架构，
本课题分析了缓存对于Picorv32架构的性能影响。然后，本章总结了目前基于Corundum所做的松散RISC-V多核
架构设计工作，并进行了上板验证与性能测试。本章还对性能测试的结果进行了分析，并给出了可能对性能造成
影响的各类技术因素。
